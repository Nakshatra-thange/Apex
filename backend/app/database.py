import os
from dotenv import load_dotenv
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker

# Load environment variables from .env file
load_dotenv()

DATABASE_URL = os.getenv("DATABASE_URL")

if not DATABASE_URL:
    raise ValueError("DATABASE_URL environment variable is not set")

# The create_async_engine function sets up connection pooling automatically.
# Here are the key parameters you can tune for production:
# - pool_size: The number of connections to keep open in the pool. (Default is 5)
# - max_overflow: The number of extra connections that can be opened beyond the pool_size
#   during a usage spike. (Default is 10)
# - pool_timeout: The number of seconds to wait before giving up on getting a connection
#   from the pool. (Default is 30)
# - echo=True: A useful debugging setting that logs all SQL queries generated by SQLAlchemy.
#   Keep this False in production to avoid logging sensitive data.

engine = create_async_engine(
    DATABASE_URL,
    pool_size=10,
    max_overflow=20,
    echo=True  # <-- CHANGE THIS TO TRUE
)
# The AsyncSession sessionmaker is configured to use our engine's connection pool.
AsyncSessionLocal = sessionmaker(
    bind=engine,
    class_=AsyncSession,
    expire_on_commit=False,
)

async def get_db() -> AsyncSession:
    """
    Dependency injection function to get a database session.
    Ensures the session is properly closed after the request is handled.
    """
    async with AsyncSessionLocal() as session:
        try:
            yield session
        finally:
            await session.close()